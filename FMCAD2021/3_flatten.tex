%!TEX root = paper.tex

In this section, we first define the class of string constraints with string-integer conversion, denoted by $\strint$. Then we define the extension of Presburger arithmetic with exponential functions, denoted by $\paexp$. Finally, we show how to flatten the string constraints in $\strint$ into the arithmetic constraints in $\paexp$.

\subsection{String constraints with string-integer conversion ($\strint$)}

In the sequel, we shall define $\strint$, the class of string constraints with the string-integer conversion function {\parseInt}.

The function  {\parseInt} takes a decimal string as the input and returns the integer represented by the string\footnote{The {\parseInt} function in scripting languages e.g. Javascript is more general in the sense that the base can be a number between 2 and 36. Although our approach works for arbitrary positive bases, we choose to focus on the base 10 in this paper, for readibility.}.
%Since we focus on the decidability,
%we define a binary version of {\parseInt},
%which takes a binary string and returns a decimal integer number.
For example,
${\parseInt}('0123') = {\parseInt}('123')=10^2+10*2+3 = 123$. 
Note here we use the quotation marks to delimit the strings, 
%Clearly,  our decision procedure given in this paper 
%can be adapted to string constraints with other string to number conversion function without substantial change. 
%Single quotation marks are used to distinguish a symbol like $'1'\in \Sigma$
%from a number $1_\mathbb{N}\in \mathbb{N}$ when needed.

Formally, the semantics of the $\parseInt$ function is defined as follows. 
%\begin{definition} 
Let $\Sigma_{\textit{num}}=\{0,1, \ldots, 9\}$. Then ${\parseInt}: \Sigma_{\textit{num}}^+ \mapsto \Nat$ is recursively defined by
    for every $w\in \Sigma_{\textit{num}}^+$,
    \begin{itemize}
%        \item if $|w|=0$, i.e., $w=\epsilon$,  ${\parseInt}(w)=0$;
        \item if $w={'i'}$ for $i \in \Sigma_{\textit{num}}$, then ${\parseInt}('i')=i$;
        \item for $w = w_1 {'i'}$ for $i \in \Sigma_{\textit{num}}$ with $|w_1| \ge 1$, 
        ${\parseInt}(w) = 10*{\parseInt}(w_1)+{\parseInt}({'i'})$.
    \end{itemize} 
%\end{definition}
Note that $\parseInt$ is undefined with $\varepsilon$ as the input.


In $\strint$, there are two types of variables, namely, the string variables $\svarx,\svary,\ldots \in \svars$ and the integer variables $\ivarx,\ivary,\ldots \in \ivars$.
%
A $\strint$ formula $\varphi$ is defined by the following rules, where $\len(\sterm)$ denotes the length of a string $\sterm$.
\[
\begin{array}{l c l}
\sterm & \Def & a \mid \svarx \mid \sterm \concat \sterm, \\
\iterm & \Def & n \mid \ivarx \mid \len(\sterm) \mid \parseInt(\sterm) \mid \iterm + \iterm \mid \iterm - \iterm,\\
\varphi & \Def & \sterm = \sterm \mid x \in \Aut \mid \iterm\ \op\ \iterm \mid \varphi \wedge \varphi \mid \varphi \vee \varphi \mid \neg \varphi,
\end{array}
\]
where $a \in (\Sigma_{\textit{num}})_\varepsilon$, $n \in \Nat$, $\Aut$ is an FA, and $\op \in \{=, < , >, \le, \ge\}$. Let us call $\sterm$ as string terms, $\iterm$ as integer terms, $\sterm = \sterm$ as string equality constraints, $x \in \Aut$ as regular constraints, $\iterm \op\ \iterm$ as arithmetic constraints. 
Let  $\svar(\varphi)$ and $\ivar(\varphi)$ denote the set of string variables and integer variables respectively occurring in $\varphi$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
\paragraph{String Terms}
Given a finite alphabet $\Sigma$ and 
a finite set $X$ of string variables over $\Sigma^*$,
we define the set of terms $\textit{Terms}(\Sigma,X)$ 
to be the smallest set satisfying
\begin{itemize}
    \item[1] $\Sigma\cup \{\epsilon\} \cup X \subseteq \textit{Terms}(\Sigma,X)$;
    \item[2] if $t_1,t_2\in \textit{Terms}(\Sigma,X)$, then $t_1 \cdot t_2 \in \textit{Terms}(\Sigma,X)$.
\end{itemize} 

We extend $I_X$ to $\textit{Terms}(\Sigma,X)$ by letting $I_X(\epsilon)=\epsilon$, 
for $a\in \Sigma, I_X(a)=a$,
and $I_X(t_1\cdot t_2)= I_X(t_1)\cdot I_X(t_2)$.

\paragraph{String Constraints} \label{par: string constraints}
Given a constraint $\phi$ and an interpretation $I$,
$I\models \phi$ denotes that $I$ satisfies $\phi$,
and $I$ is called a \emph{model} of $\phi$.
We use $\lVert \phi\rVert$ to denote the set of all models of $\phi$.

We define the following three forms of atomic string constraints:
\begin{itemize}
\item An equality constraint $\phi_e$ is of the form 
$t_1 = t_2$, where $t_1,t_2\in \textit{Terms}(\Sigma,X)$.
We define $\lVert \phi_e \rVert = \{I\mid I(t_1)=I(t_2)\}$.
Inequality constraints can be defined analogously.

\item A regular constraint $\phi_r$ is of the form 
$x\in L(\mathcal{A})$,
where $x\in \mathbb{X}$ and $\mathcal{A}$ is a finite state automaton.
We define $\lVert \phi_r \rVert = \{I\mid I(x)\in L(\mathcal{A})\}$.

\item A length constraint $\phi_l$ is a linear constraint over 
$Z \cup \{|x| \mid x\in X\}$, %the values of $|x|$ for all $x\in X$,
where $|\cdot |$ is the length function.
We define $\lVert \phi_l \rVert = \{I \mid I\models \phi_l \}$.
\end{itemize}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The $\strint$ formulas are interpreted on $I=(I_s, I_i)$ where $I_s$ is a partial function from $\svars$ (the set of string variables) to $\Sigma^*$ and $I_i$ is a partial function from $\ivars$ (the set of integer variables) to $\Nat$. Moreover, it is required that the domains of $I_s, I_i$ are finite. Given $I = (I_s, I_i)$, the interpretations of string terms, integer terms, as well as the formulas $\varphi$ under $I$ are easy to comprehend, thus omitted to avoid tediousness. For $\varphi \in \strint$ and $I = (I_s, I_i)$, $I$ satisfies $\varphi$ if the interpretation of $\varphi$ under $I$ is $\ltrue$.
Let us use $\lVert \varphi \rVert$ to denote the set of $I = (I_s, I_i)$ satisfying $\varphi$.

\begin{example}
some example for $\strint$ here
\end{example}

%As usual, an interpretation $I$ is a mapping from the set of variables $X\cup Z$ to the respective domain, 
%essentially a pair of two mappings 
%$I_X$ and $I_Z$, i.e., $I= (I_X, I_Z)$,  
%where $I_X$ is a mapping in $X \mapsto \Sigma^*$ and $I_Z$ is a mapping in $Z \mapsto \mathbb{N}$.

The satisfiability problem of $\strint$ is to decide for a given constraint $\varphi \in \strint$,
whether $\lVert  \varphi \rVert \neq \emptyset$.
%if not, to compute an interpretation $I$ that satisfies $\Psi$.

\subsection{An Extension of Presburger Arithmetic with Exponential Functions ($\paexp$)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
For a first order theory $T$,
we say theory $T$ admits quantifier elimination (QE) if for any formula in $T$, 
there is a quantifier-free formula equivalent to it.
It is well-known that if a theory admits QE, 
then it is a decidable theory.

The formal definition of PA is given in section \ref{PA}.
Here we add the ordering predicate $\le$ into the signature,
which can be defined by $x \le y\, \Def \, \exists z. x+z=y$.
However, the theory PA so far does not admit QE, 
for example, consider the formula $\exists x.x = y + y$. 
We augment the theory with countable unary divisible predicates
$n|x$, where $n\in \mathbb{N}$, 
$n|x$ is true if and only if $x\ \text{mod}\ n=0$ holds.
This structure of PA that admits QE is denoted by $(\mathbb{N},+)$.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\paexp} extends Presburger arithmetic with the exponential function $10^x$ as well as the (partial) functions $\ell_{10}(\ivarx)$ and $\lambda_{10}(\ivarx)$ (cf. \cite{Point86}). The functions $\ell_{10}(\ivarx)$ and $\lambda_{10}(\ivarx)$ are inductively defined as follows.
\begin{itemize}
\item The (partial) function $\ell_{10}(\ivarx)$ is inductively defined as follows: For $n \ge 1$, $\ell_{10}(n) = m$ iff $10^m \le n < 10^{m+1}$. \wuhao{For $n \le 0$, we define $\ell_{10}(n)=0$}

%(Note that $\ell_{10}(0)$ is undefined.) 
%
\item The (partial) function $\lambda_{10}(\ivarx)$ can be defined by $\ell_{10}(\ivarx)$: For $n \ge 1$, $\lambda_{10}(n) = 10^{\ell_{10}(n)}$. (Intuitively, $\lambda_{10}(\ivarx)$ is the maximum power of 10 that is no greater than $\ivarx$.)
\end{itemize}

The syntax of {\paexp} is obtained from that of {\pa} by adding $10^\iterm$, $\ell_{10}(\iterm)$ and $\lambda_{10}(\iterm)$ to the definition of integer terms. Specifically, {\paexp} formulas are defined by the rules,
%
 $$
 \begin{array}{ l c l}
 \iterm &\Def& c \mid \ivarx \mid \iterm + \iterm \mid \iterm - \iterm \mid 10^\iterm \mid \ell_{10}(\iterm) \mid \lambda_{10}(\iterm), \\
 \phi &\Def & \iterm \ \op\ \iterm \mid c | \iterm \mid \phi \wedge \phi \mid \phi \vee \phi \mid \neg \phi \mid \exists \ivarx.\ \phi \mid \forall \ivarx.\ \phi.
 \end{array}
 $$
 The semantics of {\paexp} are defined similarly as {\pa}.

\begin{example}
Some example of  {\paexp} here.
\end{example} 
 
%Moreover, we introduce an abbreviation $\lambda_{10}(\ivarx) \equiv 2^{\ell_{10}(\ivarx)}$.
From the definition of $\lambda_{10}(\ivarx)$, we know that for all $n \ge 1$, $\lambda_{10}(n) \le n \le 10\lambda_{10}(n)-1$ holds.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
\begin{definition}
    Let $\mathcal{L}=\{0,1,+,\le,n \, |x(n\in \mathbb{N}),2^x,l_2(x)\}$, 
     $(\mathbb{N},+,2^x)$ be a $\mathcal{L}$-theory that has domain $\mathbb{N}$, where 
    \begin{itemize}
        \item  $2^x$ is interpreted to the exponential function of $2$ over $\mathbb{N}$; 
        \item interpretations of $0,1,+,\le,=$ are consistent with PA;
        \item for $n\ge 1$,$n|x$ holds iff $\exists y.x=ny$;
        \item $2^0=1$, for $n \ge 1, 2^n = 2^{n-1}+2^{n-1}$;
        We further assume that if $m,n\in \mathbb{N}, m\le n$, 
        then $2^{m-n} = 1$
        \item $l_2(0)=0$; for $n \ge 1,l_2(n) = y$ iff $2^y \le n < 2^{y+1}$;  $l_2(m-n) = 0$
        if $m,n\in \mathbb{N}$ and $m\le n$. 
    \end{itemize}
\end{definition}

$\lambda_2(x) = 2^{l_2(x)}$ can be defined by $l_2(x)$,
intuitively, $\lambda_2(x)$ means the maximal power of 2 that is not larger than $x$.
Then we have $\lambda_2(x) \le x \le 2\lambda_2(x)-1$,
which will be useful in our proof. 
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Flattening $\strint$ into $\paexp$}

We first recall the flattening approach for string constraints in \cite{Parosh:20:PLDI}, then show how to extend it to deal with the {\parseInt} function.

A \emph{flat domain restriction} for a string constraint $\varphi$ is a function $\flatfun_\varphi$ that maps each string variable $\svarx \in \svar(\varphi)$ to a flat language $(w_{\svarx,1})^* \cdots (w_{\svarx, k_\svarx})^*$, where $w_{\svarx, i} \in \Sigma_{\textit{num}}^+$ for every $i \in [k_\svarx]$. 
%
The flattened semantics of $\phi \in \strint$ is defined as $\llbracket \varphi \rrbracket_{\flatfun_\varphi} = \{(I_s, I_i) \in \llbracket \varphi  \rrbracket \mid \forall \svarx \in \svar(\varphi).\ I_s(x) \in  \flatfun_\varphi(\svarx)\}$.  

The flattening of $\varphi \in \strint$ under a flat domain restriction $\flatfun_\varphi$ is a {\paexp} formula, denoted by $\flatten_{\flatfun_\varphi}(\varphi)$, that encodes its flattened semantics.
%
More concretely, $\flatten_{\flatfun_\varphi}(\varphi)$ is a formula over the integer variables $\ivar(\varphi)$,  and Parikh variables $\pvar_{\flatfun_\varphi}(\varphi) = \bigcup_{\svarx \in \svar(\varphi)} \pvar_{\flatfun_\varphi}(\svarx)$, where $\pvar_{\flatfun_\varphi}(\svarx) = \{\#_{\svarx,i} \mid i \in [k_\svarx]\}$, called \emph{flattening variables}, plus some other auxiliary variables, such that 
%
$$\llbracket \phi \rrbracket_\kell =\decode_{\flatfun_\varphi}(\llbracket \flatten_{\flatfun_\varphi}(\varphi) \rrbracket |_{\ivar(\phi) \cup \pvar_{\flatfun_\varphi}(\varphi)})$$
%
The decoding function above decodes an interpretation of integer and flattening variables $I_e: \ivar(\varphi) \cup \pvar_{\flatfun_\varphi}(\varphi) \rightarrow \Nat$ as a set $\decode_{\flatfun_\varphi}(I_e)$ of interpretations of the $\varphi$'s integer and string variables $(I_s, I_i)$ with $I_s: \svar(\varphi) \rightarrow \Sigma^*$ and $I_i: \ivar(\phi) \rightarrow \Nat$ such that 
\begin{itemize}
\item  
for every $ \svarx \in \svar(\varphi)$, $I_s(\svarx) = w_{\svarx,1}^{I_e(\#_{\svarx,1})} \ldots  w_{\svarx,k_\svarx}^{I_e(\#_{\svarx,k_\svarx})}$, 
%
\item for every $ \ivarx \in \ivar(\varphi)$, $I_i(\ivarx) = I_e(\ivarx)$.
\end{itemize}

The formula $\flatten_{\flatfun_\varphi}(\varphi)$ is constructed inductively by following the structure of $\varphi$: $\flatten_{\flatfun_\varphi}(\varphi_1\ \mathfrak{o}\ \varphi_2) = \flatten_{\flatfun_\varphi}(\varphi_1) \ \mathfrak{o}\  \flatten_{\flatfun_\varphi}(\varphi_2)$, where $\mathfrak{o} \in \{\wedge, \vee\}$, and $\flatten_{\flatfun_\varphi}(\neg \varphi_1) = \neg \flatten_{\flatfun_\varphi}(\varphi_1)$. Therefore, it is sufficient to show how to construct $\flatten_{\flatfun_\varphi}(\varphi)$ for atomic constraints $\varphi$. 
In the sequel, we will show how to construct $\flatten_{\flatfun_\varphi}(\iterm_1 \op \iterm_2)$ where $\parseInt(\sterm)$ may occur in $\iterm_1$ or $\iterm_2$. The construction of $\flatten_{\flatfun_\varphi}(\varphi)$ for the other atomic constraints is essentially the same as that in \cite{Parosh:20:PLDI} and thus omitted. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
The flattening technique was first introduced 
in \cite{Abdulla 2017}.
Fix an alphabet $\Sigma$ and an abstraction parameter $\alpha$, 
for a given atomic string constraint $\phi$, 
flattening $\phi$ with parameter $\alpha$ 
results in a new string constraint $\phi_\alpha$,
such that 
$R(\lVert \phi_\alpha \rVert) = \lVert \phi \rVert \cap \{I \mid \forall x\in X, I(x)\in \mathbb{G}'(\alpha)\}$,
where $R$ is the renaming function with its domain extended to interpretations in the normal manner.
Intuitively, it restricts $\phi$ to interpret 
string variables over $\mathbb{G}'(\alpha)$.

\cite{Abdulla 2017} discussed the flattening of basic 
string constraints including equality, integer, (regular) grammar and transducer constraints. 
For an atomic string constraint $\phi$,
the flattening $\phi_\alpha$ is still an atomic string constraint 
and is Parikh definable,
so its Parikh image can be expressed by a quantifier free PA formula.
Together with the purity condition,
we obtain an existential quantified PA formula $\rho$.
$\rho$ will be sent to a SMT solver,
if the solver returns an solution $\theta$,
then we can construct an interpretation for $\phi_\alpha$ from $\theta$,
otherwise it means $\phi$ is unsatistiable when 
string variables are interpreted  to $\alpha$-flat languages.

Take a regular constraint $\phi = x\in L(A)$ for example,
the flattening of $\phi$ resutls in a new finite state automaton $A'$ over $\Sigma(\alpha)$,
which encodes running $A$ ``in parallel" 
with the generic $\alpha$-flat automaton.
Let $\rho_1$ be the formula describing the Parikh image of $A'$,
which is a formula over variable sets $\Sigma(\alpha)^\#$.
Let $\rho_2$ be the purity condition \eqref{eq:purity}.
Then we obtain the PA formula $\exists (\Sigma(\alpha))^\#. \rho_1 \wedge \rho_2$.
In order to distinguish between different string variables,
we may replace $a(i)^\# \in \Sigma(\alpha)^\#$ by $(x,a(i))^\#$.

Since the structure of a flat automaton is decided 
by its abstraction parameter $\alpha$, 
a Counter-Example Guided Abstraction 
Refinement (CEGAR) framework is designed, which contains both an under- and an 
over-approximation module, to search the possible values of $\alpha$.
The termination for the overall algorithm is not guaranteed.


The string-number conversion functions are commonly used functions
in most of programming languages,
for example,
\verb+parseInt()+ in Java and \verb+Int()+ in Python.
The functions usually take two parameters, 
a string over the agreed alphabet $\Sigma$
and an optional parameter denotes the radix.
They parse the string according to the rules indicated by the radix,
and return an integer denoted by the string.

From the view of string constraints,
string-number conversion functions give rise to a new form of string constraints
and are more expressive than length constraints.
So we consider extending string constraints with 
{\parseInt} function. 
As the general problem of string constraints is undecidable,
we still adopt the idea of flattening, 
i.e., variables are restricted to (generic) flat languages.
This problem has been investigated in \cite{POPL20},
which defined a special form of flat restriction (straight-line PFA) and 
proposed a heuristic search method.

In this section, 
we describe the problem of interest first, and then 
present an reduction from the problem of solving flat string constraints with {\parseInt} function
to the decidability problem of Presburger Arithmetic with exponential functions.
Hence, we identify a decidable subset of string constraints, which is the largest one with decidability so far to the best of our knowledge.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Before presenting the construction of $\flatten_{\flatfun_\varphi}(\iterm_1 \op \iterm_2)$, for every $\svarx \in \svar(\varphi)$, we define $\flatten_{\flatfun_\varphi}(\parseInt(\svarx)) = \iterm_{\svarx,1}$  such that $(\iterm_{\svarx, i})_{i \in [k_\svarx]}$ and $(\ell_{\svarx, i})_{i \in [k_\svarx]}$ are inductively defined as follows: 
\begin{itemize}
\item for $i = k_\svarx$, 
$$\iterm_{\svarx, i} = \frac{\parseInt(w_{\svarx, k_\svarx}) (10^{|w_{\svarx,k_\svarx}| \#_{\svarx, k_\svarx} } -1 )}{(10^{|w_{\svarx, k_\svarx}|} -1 )}$$ 
and $\ell_{\svarx, i} = |w_{\svarx,k_\svarx}| \#_{\svarx, k_\svarx}$,
%
\item for $i \in [k_\svarx-1]$, 
%
$$\iterm_{\svarx, i} =  \frac{\parseInt(w_{\svarx, i}) (10^{|w_{\svarx, i} | \#_{\svarx, i} } -1 ) 10^{\ell_{\svarx, i+1}}} {(10^{|w_{\svarx, i}|} -1 )} + \iterm_{\svarx, i+1}$$
%
and $\ell_{\svarx, i} = |w_{\svarx, i} | \#_{\svarx, i} + \ell_{\svarx, i+1}$.
\end{itemize}

Then $\flatten_{\flatfun_\varphi}(\iterm_1 \op \iterm_2)$ is obtained from $\iterm_1 \op \iterm_2$ by the following procedure.
\begin{enumerate}
\item Replace each integer term $\len(t)$ such that $t = \alpha_1 \ldots \alpha_m$ with $\alpha_i \in \Sigma_{\textit{num}} \cup \svar(\varphi)$ for every $i \in [m]$, by 
 $\sum \limits_{i \in [m]} \theta_i$, where for every $i \in [m]$, $\theta_i = 1$ if $\alpha_i \in \Sigma_{\textit{num}}$ and $ \theta_i = \sum \limits_{j \in [k_{\alpha_i}]} |w_{\alpha_i, j} | \#_{\alpha_i, j}$ otherwise.
%
\item  Replace each integer term $\parseInt(\sterm)$ such that $t = \alpha_1 \ldots \alpha_m$ with $\alpha_i \in \Sigma_{\textit{num}} \cup \svar(\varphi)$ for every $i \in [m]$, by $\iterm_{\parseInt(\sterm)}$, where $\iterm_{\parseInt(\sterm)} = \iterm_{t,1}$ such that $(\iterm_{t,i})_{i \in [m]}$ and $(\ell_{t, i})_{i \in [m]}$ are inductively defined as follows: 
\begin{itemize}
\item if $\alpha_m \in \Sigma_{\textit{num}}$, then $\iterm_{t, m} = \alpha_m$ and $\ell_{t, m} = 1$, otherwise, $\iterm_{t, m} = \flatten_{\flatfun_\varphi}(\parseInt(\alpha_m))$ and $\ell_{t, m} = \sum \limits_{j \in [k_{\alpha_m}]} |w_{\alpha_m, j}| \#_{\alpha_m, j}$,
%
\item for $i \in [m-1]$, if $\alpha_i \in \Sigma_{\textit{num}}$, then $\iterm_{t, i} = \alpha_i 10^{\ell_{t, i+1}} + \iterm_{t, i+1}$ and $\ell_{t, i} = \ell_{t, i+1}+1$, otherwise, $\iterm_{t, i} = 
\flatten_{\flatfun_\varphi}(\parseInt(\alpha_i))10^{\ell_{t, i+1}}  + \iterm_{t, i+1}$ and $\ell_{t, i} = \ell_{t, i+1} + \sum \limits_{j \in [k_{\alpha_i}]} |w_{\alpha_i, j}| \#_{\alpha_i, j}$.
\end{itemize}
%
\item Let $\iterm'_1 \op \iterm'_2$ be the formula resulting from the aforementioned replacements. (Note that strictly speaking, $\iterm'_1 \op \iterm'_2$ is not a $\paexp$ formula since it contains divisions.) Let $N$ be the least common multiplier of the denominators of $\iterm'_1$ and $\iterm'_2$.  Then $\flatten_{\flatfun_\varphi}(\iterm_1 \op \iterm_2)$ is obtained by multiplying the both sides of $\iterm'_1 \op \iterm'_2$ with $N$,  so that the division operator disappears. 
\end{enumerate}

\begin{example}
Suppose $\parseInt(\svarx) = 2\ivarx$ is an atomic constraint and $\flatfun_\varphi(\svarx) = 1^*2^*$. Then 
\[
\small
\begin{array}{l l}
& \flatten_{\flatfun_\varphi}(\parseInt(\svarx)  =  2\ivarx)  \\
\Def & 1 \frac{10^{\#_{\svarx,1}}-1}{10-1}10^{\#_{\svarx,2}}  + 2 \frac{10^{\#_{\svarx,2}}-1}{10-1} = 2\ivarx   \\
\equiv & 10^{\#_{\svarx,1}+\#_{\svarx,2}} - 10^{\#_{\svarx,2}}  + 2 (10^{2\#_{\svarx,2}}-1) = 18\ivarx \\
\equiv & 10^{\#_{\svarx,1}+\#_{\svarx,2}} +  10^{\#_{\svarx,2}} = 18\ivarx + 2.
\end{array}
\]
%Take $n={\parseInt}((11)^a(10)^b)$ for example.
%\begin{align}
%    n=& {\parseInt}((11)^a)\cdot 2^{2b} + {\parseInt}((10)^b) \notag \\
%    =& {\parseInt}(11)\cdot \frac{2^{2a}-1}{2^2-1}\cdot 2^{2b} + 
%    {\parseInt}(10) \cdot \frac{2^{2b}-1}{2^2-1} \notag 
%\end{align}
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
Now, we introduce a new form of atomic string constraints: 
a {\parseInt} constraint $\phi$ is of the form 
$n \sim {\parseInt}(t)$,
where $n$ is an integer term, $\sim \in \{\le,<,=,>,\ge\}$ and $t\in \textit{Terms}(\Sigma_{\textit{num}},X)$ is a string term.
$\lVert \phi\rVert \Def  \{I \mid I(n)\sim {\parseInt}(I(t))\}$.

In what follows, we only  consider the problem in the case when $t=x$ and $x$ is restricted to (generic) flat languages. 
%If $t$ is not a single variable, 
For the general case $t\in \textit{Terms}(\Sigma_{\textit{num}},X)$, 
it can be reduced to this special case by induction on the structure of $t$. 
%we can reduce the problem by separating $t$ (corresponding to the $|w|>2$ case in definition).

Given an $\alpha$-flat language $L$,
we assume $\alpha=\langle p,q \rangle$ and $L=(w_1)^*...(w_q)^*$,
where $p,q$ and $w_i(1\le i \le q) $ are known.
We further assume that $x = (w_1)^{\beta_1} ... (w_q)^{\beta_q}$,
then we have
\begin{align}
    &{\parseInt}(x) \notag \\
    =&{\parseInt}((w_1)^{\beta_1} ... (w_q)^{\beta_q}) \notag \\
    =&{\parseInt}((w_1)^{\beta_1} ... (w_{q-1})^{\beta_{q-1}})\cdot 2^{\beta_q |w_q|}
    + {\parseInt}((w_q)^{\beta_q}) \label{parse}
\end{align}
(\ref{parse}) is a recursive expression.
So we only need to deal with the basic case ${\parseInt}((w_q)^{\beta_q})$, 
where $w_q \neq \epsilon$
\begin{align}
    {\parseInt}((w_q)^{\beta_q}) &= \sum_{i=0}^{\beta_q-1} {\parseInt}(w_q)\cdot 2^{|w_q|\cdot i}  \notag \\
    &={\parseInt}(w_q)\frac{2^{|w_q|\cdot \beta_q}-1}{2^{|w_q|}-1}
    \label{parseInt-basic}
\end{align}
In (\ref{parseInt-basic}), since $w_q$ and $|w_q|$ are known, 
they can be regarded as constants.
The only unknown variable is $\beta_q$.

Combine (\ref{parse}) and (\ref{parseInt-basic}),
the constraint $n={\parseInt}(x)$ can be expressed by an arithmetic expression with 
$n$ and $(\beta_1,...,\beta_q)$,
inevitably with exponential components.

Observe the form of the above equation,
$a,b,n$ are integer variables and either occur in 
an exponential term or a linear term.
This is always the case,
so the problem can be reduced to 
the decidability of PA with exponential function.

When $x$ of {\parseInt} constraints is restricted to the
generic $\alpha$-flat language ($\alpha$ is fixed),
the (\ref{parse}) and (\ref{parseInt-basic}) still hold 
but $w_i(1\le i\le q)$ is known.
However,
by definition,
the generic $\alpha$-flat language is the finite union of all $\alpha$-flat languages,
so we can enumerate all possible values for $w_i$.
In this way,
the problem can still be reduced to the decidability of PA with exponential function ($\paexp$), i.e.,
\begin{theorem} \label{thm:string-parInt}
If {$\paexp$} is decidable, then the satisfiability (validity) of string constraints with {\parseInt} in which all string variables 
are ranged over flat strings is decidable. 
\end{theorem}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



