The string-number conversion functions are commonly used functions
in most of programming languages,
for example,
\verb+parseInt()+ in Java and \verb+Int()+ in Python.
The functions usually take two parameters, 
a string over the agreed alphabet $\Sigma$
and an optional parameter denotes the radix.
They parse the string according to the rules indicated by the radix,
and return an integer denoted by the string.

From the view of string constraints,
string-number conversion functions give rise to a new form of string constraints
and are more expressive than length constraints.
So we consider extending string constraints with 
{\parseInt} function. 
As the general problem of string constraints is undecidable,
we still adopt the idea of flattening, 
i.e., variables are restricted to (generic) flat languages.
This problem has been investigated in \cite{POPL20},
which defined a special form of flat restriction (straight-line PFA) and 
proposed a heuristic search method.

In this section, 
we describe the problem of interest first, and then 
present an reduction from the problem of solving flat string constraints with {\parseInt} function
to the decidability problem of Presburger Arithmetic with exponential functions.
Hence, we identify a decidable subset of string constraints, which is the largest one with decidability so far to the best of our knowledge.

\subsection{String-Number Conversion Function}

Commonly, 
{\parseInt} function takes a string representation of a decimal
number and returns an integer.
Since we focus on the decidability,
we define a binary version of {\parseInt},
which takes a binary string and returns a decimal integer number.
For example,
${\parseInt}('111')=7$. 
Clearly,  our decision procedure given in this paper 
can be adapted to string constraints with other string to number conversion function without substantial change. 
Single quotation marks are used to distinguish a symbol like $'1'\in \Sigma$
from a number $1_\mathbb{N}\in \mathbb{N}$ when needed.


\begin{definition} Let $\Sigma_{\textit{num}}=\{'0','1'\}$,
 ${\parseInt}:\Sigma_{\textit{num}}^*\mapsto \mathbb{N}$ is recursively defined by:
    for $w\in \Sigma_{\textit{num}}^*$
    \begin{itemize}
        \item if $|w|=0$, i.e., $w=\epsilon$,  ${\parseInt}(w)=0$;
        \item if $|w|=1, {\parseInt}('w')=w_\mathbb{N}$;
        \item for $|w|\ge 2$ and $w=w_1 \cdot w_2$, 
        where $|w_1|, |w_2| \ge 1$, 
        ${\parseInt}(w) = {\parseInt}(w_1)2^{|w_2|}+{\parseInt}(w_2)$.
    \end{itemize} 
\end{definition}

Now, we introduce a new form of atomic string constraints: 
a {\parseInt} constraint $\phi$ is of the form 
$n \sim {\parseInt}(t)$,
where $n$ is an integer term, $\sim \in \{\le,<,=,>,\ge\}$ and $t\in \textit{Terms}(\Sigma_{\textit{num}},X)$ is a string term.
$\lVert \phi\rVert \Def  \{I \mid I(n)\sim {\parseInt}(I(t))\}$.

In what follows, we only  consider the problem in the case when $t=x$ and $x$ is restricted to (generic) flat languages. 
%If $t$ is not a single variable, 
For the general case $t\in \textit{Terms}(\Sigma_{\textit{num}},X)$, 
it can be reduced to this special case by induction on the structure of $t$. 
%we can reduce the problem by separating $t$ (corresponding to the $|w|>2$ case in definition).

Given an $\alpha$-flat language $L$,
we assume $\alpha=\langle p,q \rangle$ and $L=(w_1)^*...(w_q)^*$,
where $p,q$ and $w_i(1\le i \le q) $ are known.
We further assume that $x = (w_1)^{\beta_1} ... (w_q)^{\beta_q}$,
then we have
\begin{align}
    &{\parseInt}(x) \notag \\
    =&{\parseInt}((w_1)^{\beta_1} ... (w_q)^{\beta_q}) \notag \\
    =&{\parseInt}((w_1)^{\beta_1} ... (w_{q-1})^{\beta_{q-1}})\cdot 2^{\beta_q |w_q|}
    + {\parseInt}((w_q)^{\beta_q}) \label{parse}
\end{align}
(\ref{parse}) is a recursive expression.
So we only need to deal with the basic case ${\parseInt}((w_q)^{\beta_q})$, 
where $w_q \neq \epsilon$
\begin{align}
    {\parseInt}((w_q)^{\beta_q}) &= \sum_{i=0}^{\beta_q-1} {\parseInt}(w_q)\cdot 2^{|w_q|\cdot i}  \notag \\
    &={\parseInt}(w_q)\frac{2^{|w_q|\cdot \beta_q}-1}{2^{|w_q|}-1}
    \label{parseInt-basic}
\end{align}
In (\ref{parseInt-basic}), since $w_q$ and $|w_q|$ are known, 
they can be regarded as constants.
The only unknown variable is $\beta_q$.

Combine (\ref{parse}) and (\ref{parseInt-basic}),
the constraint $n={\parseInt}(x)$ can be expressed by an arithmetic expression with 
$n$ and $(\beta_1,...,\beta_q)$,
inevitably with exponential components.

Take $n={\parseInt}((11)^a(10)^b)$ for example.
\begin{align}
    n=& {\parseInt}((11)^a)\cdot 2^{2b} + {\parseInt}((10)^b) \notag \\
    =& {\parseInt}(11)\cdot \frac{2^{2a}-1}{2^2-1}\cdot 2^{2b} + 
    {\parseInt}(10) \cdot \frac{2^{2b}-1}{2^2-1} \notag 
\end{align}

So we have 
\begin{equation}
    3\cdot n = 3\cdot 2^{2a+2b}-3\cdot 2^{2b}+2\cdot 2^{2b}-2. \notag
\end{equation}

Observe the form of the above equation,
$a,b,n$ are integer variables and either occur in 
an exponential term or a linear term.
This is always the case,
so the problem can be reduced to 
the decidability of PA with exponential function.

When $x$ of {\parseInt} constraints is restricted to the
generic $\alpha$-flat language ($\alpha$ is fixed),
the (\ref{parse}) and (\ref{parseInt-basic}) still hold 
but $w_i(1\le i\le q)$ is known.
However,
by definition,
the generic $\alpha$-flat language is the finite union of all $\alpha$-flat languages,
so we can enumerate all possible values for $w_i$.
In this way,
the problem can still be reduced to the decidability of PA with exponential function (\paexp), i.e.,
\begin{theorem} \label{thm:string-parInt}
If {\paexp} is decidable, then the satisfiability (validity) of string constraints with {\parseInt} in which all string variables 
are ranged over flat strings is decidable. 
\end{theorem}


