The emerging of scripting languages boosted the needs of better approaches and tools to ensure program quality.
Comparing with traditional programming languages, string data type plays a more critical role in its analysis.
String constraint solvers are the engine of modern scripting program analysis techniques. 
Due to the high demand, in recent years, there is a boosting amount of publications on this subject.

However, research progress of string constraint solving has been hampered by many major obstacles in both theory and tool implementation aspects (including long-standing open problems). 
Logical theories over strings have to allow string concatenation, which is arguably the most fundamental operation of strings. 
The most celebrated result concerning theories of strings is Makanin’s result on deciding the satisfiability problem for \emph{word equations}~\cite{}.
A simple example of a word equation is $xaby = ybax$, where $x, y$ are variables, and $a, b \in \Sigma$ are constant letters. 
A word equation is satisfiable if it has a solution, i.e., an assignment that maps variables to strings over the alphabet $\Sigma$ which equate the left-hand side with the right-hand side of the equation.
The correctness proof of Makanin’s algorithm is arguably one of the most complex termination proofs in computer science. 
Makanin’s result can be extended to include \emph{regular constraints} (a.k.a. regular expression matching, e.g., $x \in (ba)^*)$, and arbitrary Boolean connectives.
This extension is called word equations with regular constraints. 
However, the satisfiability problem of word equation together with length constraints (e.g., $|x|=|y|+1 \wedge wx=yx$) is still open.
The complexity of the satisfiability of word equations with regular constraints was proven to be PSPACE-complete by Plandowski~\cite{}, after decades of improvement of the original algorithm by Makanin.

Satisfiability of word equations is a special instance of Hilbert’s 10th problem. 
In the past, the original motivation of studying word equations was for finding an undecidability proof of Hilbert’s 10th problem. 
However, the motivation is no longer valid since Makanin finds a decision procedure. Interestingly, in the last decade, driven by the need for program analysis, people start to revisit the problem and its extensions to describe the complete string library APIs in conventional programming languages.

The satisfiability of \emph{string/number conversion constraints} \yfc{give example} has been proven undecidable in~\cite{}. 
It is undecidable even without combining with other types of string constraints. \yfc{double check}
However, this kind of constraint is pervasive in scripting language programs. 
For example, it is common that programs read string input from text files and conversion a part of the string input to numbers.
Even more crucially, in many programming languages, the string-number conversion is a part of the definition of their core semantics. 
JavaScript, which powers most interactive content on the Web and increasingly server- side code with Node.js, is one of such languages. 

Due to the difficulties in solving string constraints and, in practice, satisfiable string constraints are more critical for automatic testing, one idea is to have separate specialized procedures for solving satisfiable instances. 
Currently, there are two main specialized approaches for proving satisfiability.
The first is to consider only strings of bounded length.
This approach is taken in earlier generation solvers such as Hampi and Kuluza~\cite{}.
Although they are useful in handling many practical cases, they fail short when the all string solutions exceed the selected bound.
For example, a constraint of the form $x.y \neq z  \wedge |x| > 2000$ would be quite challenging to handle using those solvers.

One more recent approach is flattening~\cite{A}.
The idea is to restrict the solution space of string variables to some pattern defined by \emph{flat automata} (see Section~\ref{PA} for more details). 
The major benefit of considering this class is two folds.
First, even under the restriction, often the potential solution space is still infinite, which gives us a higher potential of finding solutions.
For instance, we can find a solution for $x.y \neq z  \wedge |x| > 2000$ under a very simple restriction: all variables are in $a^*$, which $a$ is a character in our alphabet.
Second, and more importantly, because we can convert the membership problem of a flat automaton to a satisfiability problem of Presburgher formula, the class of word equation + regular constraints + length constraints is decidable.

The paper of Abdulla et al. has considered adding string/number conversion constraints to the above class.
The paper proposes a decision procedure with a restricted form of flat automata.
For string/number conversion, their approach projects the solution to string/number conversion to, in terms of numerical solutions, a finite solution space.

In this paper, we propose a complete solution to this problem.
We propose a decision procedure for the class of word equation + regular constraints + length constraints + string/number conversion under arbitrary flat automata (denoted by $\strint$).
The basic idea of our approach can be sketched as follows:  similar to \cite{A}, we first reduce the satisfiability problem of $\strint$ to the corresponding satisfiability problem of the theory of Presburger Arithmetic with exponential functions (denoted by $\paexp$); then, according to the decidability of $\paexp$ \cite{Semenov84}, we therefore obtain the decidability of the satisfiability of $\strint$.  

In \cite{Semenov84}, Semen\"{o}v just proved that $\paexp$ admits quantifier elimination property and 
therefore obtained that its satisfiability is decidable, but  did not provide an explicit decision procedure. So, in  \cite{Point86}, Point presented a first decision procedure for the satisfiability of $\paexp$ in a mathematical way, which is difficult to understand and therefore no implementation available based on which up to now to the best of our knowledge. So, another contribution of this paper is that we present a more understandable algorithm for $\paexp$'s satisfiability in a computational way and its prototypical implementation. Although the general framework of our algorithm is quite akin to Point's,  it contains the following improvements and corrections: 
\begin{itemize}
	\item[i)] The syntax of Presburger arithmetic with exponential functions in our setting is more natural and easy to understand; Point's algorithm needs to transform the formula into DNF (disjunction normal form) before  eliminating any variables, that could increase the length of the considered $\paexp$ formula exponentially. In contrast, our algorithm just assumes that formulas are NNF (negation normal form). Therefore, our algorithm is much easy to follow and more efficient.
\item[ii)] Unlike in Point's algorithm to eliminate the exponential part and then the linear part of the largest variable according to the given order one by one, in contrast, our algorithm eliminates the exponential parts of 
	all variables according to the order and then the resulted linear part, that improve the efficiency very much.
\item[iii)] Additionally, a sub-case of eliminating exponential terms in Point's algorithm is incorrect, we correct it by Lemma \ref{lem:exp-ineq} (see later).
\end{itemize}
 


How we did it? Also mention the quantifier elimination procedure. Optimizations

Say the problem is challenging for state-of-the-art solvers, mention the hash function example.

Experimental results.